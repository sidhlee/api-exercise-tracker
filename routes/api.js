const UserModel = require('../models/users');
const ExerciseModel = require('../models/exercise');
const router = require('express').Router(); // isolated instance of middleware and routes. "mini-app". can pass to another router's use()

router.post('/new-user', (req, res, next) => { //req.body: { username }
    
    const newUser = new UserModel(req.body);
    
    newUser.save((err, savedUser) => {
        if(err) {
            if(err.code == 11000) { //mongo error code:  uniqueness error. created if schema's unique field is set to true
                return next({
                    status: 400,
                    message: 'username already taken'
                })
            } else {
                return next(err); // pass err to the next error-handling Middleware. https://mongoosejs.com/docs/middleware.html#error-handling-middleware
            }
        }
        res.json({
            username: savedUser.username,
            _id: savedUser._id // unique string id generated by 'shortid' package
        });
    });
});


router.post('/add', (req, res, next) => { // req.body : { userId, description, duration, date }
    UserModel.findById(req.body.userId, (err, user) => {
        if(err) return next(err); 
        if(!user) { // if user not found by id, pass error to the error-handling middleware (custom-set in server.js). This helps to delegate all error responses in one place (server.js) instead of creating error response individually in each operation.
            return next({ // instead of responding with error message (eg: res.json({"error": "unkown id"}))
                status: 400, // if you call next() with an error in your code more than once, the default error handler can get triggered even if custom error handling middleware is in place
                message: 'unknown _id'
            });
        }
        const newExercise = new ExerciseModel(req.body); 
        newExercise.username = user.username; // add doc's(found by id) username to new exercise doc (req.body doesn't have one)
        newExercise.save((err, savedExercise) => {
            if(err) return next(err);
            savedExercise = savedExercise.toObject(); // objectify doc converting doc's Buffers into mongodb.Binary for proper storage in MongoDB
            delete savedExercise.__v; // remove versionKey https://mongoosejs.com/docs/guide.html#versionKey 
            savedExercise._id = savedExercise.userId; // replace mongoose-generated id with userId of the found user. (which was generated by shortid when the user was first added to db)
            delete savedExercise.userId;
            savedExercise.date = (new Date(savedExercise.date)).toDateString(); // eg."Tue Oct 31 2017"
            res.json(savedExercise);
        })
    });
});

router.get('/log', (req, res, next) => { // req.query = { userId, from, to, limit }
    const from = new Date(req.query.from) // will return "Invalid Date" for arguments not in acceptable format. (eg: '2019-12-25 XMAS!')
    const to = new Date(req.query.to)
    UserModel.findById(req.query.userId, (err, user) => {
        if(err) return next(err);
        if(!user) {
            return next({status: 400, message: 'unkown userId'})
        }
        ExerciseModel.find({
            userId: req.query.userId,
            date: {
                $lt: to != 'Invalid Date' ? to.getTime() : Date.now(), // if 'to' is invalid, set to now
                $gt: from != 'Invalid Date' ? from.getTime() : 0 // if 'from' is invalid, set to 0
            }
        }, { // mongoose Model.find takes projection as 2nd arg. (mongo collection.find takes options obj as 2nd arg and you can include projection there)
            __v: 0, 
            _id: 0
        })
        .sort('-date')
        .limit(parseInt(req.query.limit)) // don't trust req to be in the format you expect
        .exec((err, exercises) => {
            if(err) return next(err)
            const out = {
                _id: req.query.userId, // unique string id generated by shortid (when adding username)
                username: user.username,
                from: from != 'Invalid Date' ? from.toDateString() : undefined,
                to: to != 'Invalid Date' ? to.toDateString() : undefined,
                count: exercises.length,
                log: exercises.map(e => ({
                     description: e.description,
                     duration: e.duration,
                     date: e.date.toDateString()   
                    })
                )    
            };
            res.json(out);
        });
    });
});

module.exports = router;

